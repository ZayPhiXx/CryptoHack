#!/usr/bin/env python3
from pwn import remote
import json
from Crypto.Cipher import AES
from Crypto.Util.number import long_to_bytes
from Crypto.Util.Padding import unpad
import hashlib
from sympy.ntheory import discrete_log

HOST, PORT = "socket.cryptohack.org", 13379

# this two function is given by a script on the Cryptohack website

def is_pkcs7_padded(message):
    padding = message[-message[-1]:]
    return all(padding[i] == len(padding) for i in range(0, len(padding)))


def decrypt_flag(shared_secret: int, iv: str, ciphertext: str):
    # Derive AES key from shared secret
    sha1 = hashlib.sha1()
    sha1.update(str(shared_secret).encode('ascii'))
    key = sha1.digest()[:16]
    # Decrypt flag
    ciphertext = bytes.fromhex(ciphertext)
    iv = bytes.fromhex(iv)
    cipher = AES.new(key, AES.MODE_CBC, iv)
    plaintext = cipher.decrypt(ciphertext)

    if is_pkcs7_padded(plaintext):
        return unpad(plaintext, 16).decode('ascii')
    else:
        return plaintext.decode('ascii')

# Connection to the service
r = remote(HOST, PORT)

# I intercept the message from alice.
alice = r.recvline().decode()
alice = eval(alice[24:])

print(alice)

# I force bob to choose "DH64" algorithm
data = json.dumps({"supported": ["DH64"]}).encode() 
r.sendline(data)

# I intercept the message from bob
bob = r.recvline().decode()
bob = eval(bob[34:])

print(bob)

# I send the choice of bob that is DH64.
data = json.dumps({"chosen": bob["chosen"]}).encode()
r.sendline(data)

# I intercept the message from alice
alice = r.recvline().decode()
alice = eval(alice[38:])

print(alice)

# I get p,g and A
p = int(alice["p"], 16)
g = int(alice["g"], 16)
A = int(alice["A"], 16)

r.sendline(json.dumps(alice).encode())

bob = r.recvline().decode()
bob = eval(bob[22:])

# I get B from bob's message 
B = int(bob["B"], 16)

alice = r.recvline().decode()
alice_dict = eval(alice[24:])

# I get the iv and the encrypted flag from alice's message
iv = alice_dict["iv"]
ciphertext = alice_dict["encrypted_flag"]

# we found the a of alice to get the shared_secret by cracking it with sympy
a = discrete_log(p, A, g) 

print("a = ", a)

# we calculated the shared secret
shared_secret = pow(B, a, p)

print("shared secret = ", shared_secret)

# Now we can decrypt the flag.
flag = decrypt_flag(shared_secret, iv, ciphertext)
print(f"Flag: {flag}")

r.close()